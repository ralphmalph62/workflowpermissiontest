displayed_sidebar: docs
import QSOverview from '../_assets/commonMarkdown/quickstart-overview-tip.mdx'

# アーキテクチャ

StarRocksは素晴らしいアーキテクチャを持っています。システム全体は「フロントエンド」と「バックエンド」という2種類のコンポーネントのみで構成されています。フロントエンドノードは**FE**と呼ばれます。バックエンドノードは**BE**と**CN**（コンピュートノード）の2種類に分けられます。データがローカルストレージを使用する場合、BEがデプロイされ、データがオブジェクトストレージまたはHDFSに保存される場合、CNがデプロイされます。StarRocksは外部コンポーネントに依存しないため、デプロイとメンテナンスが簡素化されます。ノードはダウンタイムなしで水平にスケールできます。さらに、StarRocksはメタデータとサービスデータのレプリカメカニズムを備えており、データの信頼性を向上させ、単一障害点（SPOF）を効果的に防止します。

StarRocksはMySQL通信プロトコルと互換性があり、標準SQLをサポートしています。ユーザーはMySQLクライアントを介してStarRocksに接続し、即座に貴重な洞察を得ることができます。

## アーキテクチャの選択肢

StarRocksは、Shared-Nothingモード（各BEがそのローカルストレージ上のデータの一部を所有する）とShared-Dataモード（すべてのデータがオブジェクトストレージまたはHDFSに保存され、各CNはローカルストレージにキャッシュのみを持つ）をサポートしています。ニーズに応じてデータの保存場所を決定できます。

![アーキテクチャの選択](../_assets/architecture_choices.png)

### Shared-Nothingモード
ローカルストレージは、リアルタイムクエリに対してより優れたクエリレイテンシを提供します。

典型的なMassively Parallel Processing（MPP）データベースとして、StarRocksはShared-Nothingアーキテクチャをサポートしています。このアーキテクチャでは、BEはデータストレージと計算を担当します。BEノード上のローカルデータに直接アクセスすることで、ローカルでの計算が可能になり、データ転送とデータコピーを回避し、超高速のクエリおよびデータ分析パフォーマンスを提供します。このアーキテクチャはマルチレプリカデータストレージをサポートしており、高並行クエリを処理するクラスターの能力を高め、データの信頼性を確保します。これは、最適なクエリパフォーマンスを必要とするシナリオに最適です。

![ストレージと計算が一体となったアーキテクチャ](../_assets/shared-nothing.png)

#### ノード

Shared-Nothingアーキテクチャでは、StarRocksはFEとBEの2種類のノードで構成されています。

- FEはメタデータ管理と実行計画の構築を担当します。
- BEはクエリ計画を実行し、データを保存します。BEはローカルストレージを活用してクエリを高速化し、マルチレプリカメカニズムを使用してデータの高可用性を確保します。

##### FE

FEはメタデータ管理、クライアント接続管理、クエリ計画、およびクエリスケジューリングを担当します。各FEはBDB JE（Berkeley DB Java Edition）を使用して、メモリ内にメタデータの完全なレプリカを保存および維持し、すべてのFE間でのサービスの一貫性を確保します。FEはLeader、Follower、およびObserverとして動作できます。Leaderノードがクラッシュした場合、FollowerはRaftプロトコルに基づいてLeaderを選出します。

| **FEの役割** | **メタデータ管理**                                                                                                                                                                                                                                                                                                                                                                                                | **Leader選出**                |
| ----------- |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| ---------------------------------- |
| Leader      | Leader FEはメタデータを読み書きします。FollowerおよびObserver FEはメタデータのみを読み取ることができます。これらはメタデータの書き込みリクエストをLeader FEにルーティングします。Leader FEはメタデータを更新し、Raftプロトコルを使用してメタデータの変更をFollowerおよびObserver FEに同期します。データの書き込みは、メタデータの変更がFollower FEの半数以上に同期された後にのみ成功と見なされます。 | Leader FEは、技術的にはFollower FEによって選出されたFollowerノードでもあります。Leader選出を実行するには、クラスター内のFollower FEの半数以上がアクティブである必要があります。Leader FEが障害を起こした場合、Follower FEは新しいLeader選出を開始します。 |
| Follower    | Followerはメタデータのみを読み取ることができます。彼らはLeader FEからのログを同期およびリプレイしてメタデータを更新します。                                                                                                                                                                                                                                                                                                              | FollowerはLeader選出に参加し、これにはクラスター内のFollowerの半数以上がアクティブである必要があります。 |
| Observer   | Leader FEからのログを同期およびリプレイしてメタデータを更新します。                                                                                                                                                                                                                                                                                                                                           | Observerは主にクラスターのクエリ並行性を向上させるために使用されます。ObserverはLeader選出には参加しないため、クラスターのLeader選出の負荷を増加させません。 |

##### BE

BEはデータストレージとSQL実行を担当します。

- データストレージ: BEは同等のデータストレージ能力を持っています。FEは定義済みのルールに従ってデータをBEに分散します。BEは取り込まれたデータを変換し、必要な形式でデータを書き込み、そのデータに対してインデックスを生成します。

- SQL実行: FEは各SQLクエリをクエリのセマンティクスに基づいて論理実行計画に解析し、その後その論理計画をBEで実行できる物理実行計画に変換します。ターゲットデータを保存しているBEがクエリを実行します。これにより、データ転送やコピーの必要がなくなり、高いクエリパフォーマンスを実現します。

### Shared-Dataモード

オブジェクトストレージとHDFSは、コスト、信頼性、およびスケーラビリティの点で利点を提供します。ストレージのスケーラビリティに加えて、ストレージと計算が分離されているため、CNノードはデータの再バランスなしでオンデマンドで追加および削除できます。

Shared-Dataアーキテクチャでは、BEは「コンピュートノード（CN）」に置き換えられ、データの計算タスクとホットデータのキャッシュのみを担当します。データはAmazon S3、Google Cloud Storage、Azure Blob Storage、MinIOなどの低コストで信頼性の高いリモートストレージシステムに保存されます。キャッシュヒット時には、クエリパフォーマンスはShared-Nothingアーキテクチャと同等です。CNノードは数秒以内にオンデマンドで追加または削除できます。このアーキテクチャはストレージコストを削減し、より良いリソース分離を確保し、高い弾力性とスケーラビリティを提供します。

Shared-Dataアーキテクチャは、Shared-Nothingアーキテクチャと同様に、シンプルな設計を維持しています。これはFEとCNの2種類のノードのみで構成されています。唯一の違いは、ユーザーがバックエンドのオブジェクトストレージをプロビジョニングする必要があることです。

![ストレージと計算が分離されたアーキテクチャ](../_assets/shared-data.png)

#### ノード

Shared-Dataアーキテクチャのコーディネーターノードは、Shared-NothingアーキテクチャのFEと同じ機能を提供します。

BEはCN（コンピュートノード）に置き換えられ、ストレージ機能はオブジェクトストレージまたはHDFSにオフロードされます。CNはデータストレージを除くすべてのBE機能を実行するステートレスなコンピュートノードです。

#### ストレージ

StarRocksのShared-Dataクラスターは、オブジェクトストレージ（AWS S3, Google GCS, Azure Blob Storage, MinIOなど）とHDFSの2つのストレージソリューションをサポートしています。

Shared-Dataクラスターでは、データファイル形式はShared-Nothingクラスター（ストレージと計算が結合されている）と一貫しています。データはセグメントファイルに整理され、Shared-Dataクラスターで特別に使用されるテーブルであるCloud-Nativeテーブルでは、さまざまなインデックス作成技術が再利用されます。

#### キャッシュ

StarRocksのShared-Dataクラスターは、データストレージと計算を分離し、それぞれを独立してスケールできるようにすることで、コストを削減し、弾力性を向上させます。しかし、このアーキテクチャはクエリパフォーマンスに影響を与える可能性があります。

この影響を軽減するために、StarRocksはメモリ、ローカルディスク、リモートストレージをカバーする多層データアクセスシステムを確立し、さまざまなビジネスニーズに better に対応しています。ホットデータのクエリはキャッシュを直接スキャンし、次にローカルディスクをスキャンします。一方、コールドデータはオブジェクトストレージからローカルキャッシュにロードして、その後のクエリを高速化する必要があります。ホットデータを計算ユニットの近くに保持することで、StarRocksは真に高性能な計算と費用対効果の高いストレージを実現します。さらに、コールドデータアクセスはデータプリフェッチ戦略を通じて最適化され、クエリパフォーマンスの制限を効果的に排除しています。

テーブル作成時にキャッシュを有効にすることができます。キャッシュが有効になっている場合、データはローカルディスクとバックエンドのオブジェクトストレージの両方に同時に書き込まれます。クエリ中、CNノードはまずローカルディスクからデータを読み取ります。データが見つからない場合、バックエンドのオブジェクトストレージから取得され、同時にローカルディスクにキャッシュされます。

<QSOverview />
