---
displayed_sidebar: docs
---
import QSOverview from '../_assets/commonMarkdown/quickstart-overview-tip.mdx'

# アーキテクチャ

StarRocks は、堅牢なアーキテクチャを備えています。システムは、フロントエンドとバックエンドの 2 種類のコンポーネントのみで構成されています。フロントエンドノードは、**FE** または Coordinator ノードと呼ばれます。バックエンドノードには、**BE** と **CN** (コンピュートノード) の 2 種類があります。BE は、データのローカルストレージが使用される場合にデプロイされ、CN は、データがオブジェクトストレージまたは HDFS に保存される場合にデプロイされます。StarRocks は外部コンポーネントに依存しないため、デプロイとメンテナンスが簡素化されます。ノードは、サービスを停止することなく水平方向に拡張できます。さらに、StarRocks にはメタデータとサービスデータのレプリカメカニズムがあり、データの信頼性を高め、単一障害点 (SPOF) を効率的に防止します。

StarRocks は MySQL プロトコルと互換性があり、標準 SQL をサポートしています。ユーザーは MySQL クライアントから StarRocks に簡単に接続して、即座に価値のある洞察を得ることができます。

## アーキテクチャの選択

StarRocks は、共有なし (各 BE はローカルストレージにデータの一部を保持) と共有データ (すべてのデータはオブジェクトストレージまたは HDFS にあり、各 CN はローカルストレージにキャッシュのみを保持) をサポートしています。ニーズに応じて、データの保存場所を決定できます。

![Architecture choices](../_assets/architecture_choices.png)

### 共有なし

ローカルストレージは、リアルタイムクエリの query performance を改善します。

一般的な超並列処理 (MPP) データベースとして、StarRocks は shared-nothing アーキテクチャをサポートしています。このアーキテクチャでは、BE は data storage と計算の両方を担当します。BE モードでローカルデータに直接アクセスすることで、ローカル計算が可能になり、データ転送とデータコピーを回避し、超高速なクエリと分析パフォーマンスを提供します。このアーキテクチャは、マルチレプリカ data storage をサポートし、高並行クエリを処理するクラスタの能力を高め、データの信頼性を確保します。最適な query performance を追求するシナリオに適しています。

![shared-data-arch](../_assets/shared nothing.png)

#### ノード

shared-nothing アーキテクチャでは、StarRocks は FE と BE の 2 種類のノードで構成されています。

- FE は、メタデータ管理と実行プランの構築を担当します。
- BE は、クエリプランを実行し、データを保存します。BE は、ローカルストレージを利用してクエリを高速化し、マルチレプリカメカニズムを利用して高いデータ可用性を確保します。

##### FE

FE は、メタデータ管理、クライアント接続管理、クエリプラン、およびクエリスケジューリングを担当します。各 FE は BDB JE (Berkeley DB Java Edition) を使用して、メモリ内のメタデータの完全なコピーを保存および維持し、すべての FE で一貫したサービスを保証します。FE は、leader、follower、および observer として機能できます。leader ノードがクラッシュした場合、follower は Raft プロトコルに基づいて leader を選出します。

| **FE Role** | **Metadata management**                                                                                                                                                                                                                                                                                                                                                                                                | **Leader election**                |
| ----------- |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| ---------------------------------- |
| Leader      | leader FE はメタデータを読み書きします。Follower および observer FE は、メタデータの読み取りのみ可能です。メタデータの書き込みリクエストを leader FE にルーティングします。leader FE はメタデータを更新し、Raft プロトコルを使用してメタデータの変更を follower および observer FE に同期します。データの書き込みは、メタデータの変更が follower FE の半数以上に同期された後にのみ成功と見なされます。 | 正確に言うと、leader FE は follower ノードでもあり、follower FE から選出されます。leader 選出を実行するには、クラスタ内の follower FE の半数以上がアクティブである必要があります。leader FE が失敗すると、follower FE は別の leader 選出を開始します。 |
| Follower    | Follower はメタデータの読み取りのみ可能です。leader FE からログを同期および再生して、メタデータを更新します。                                                                                                                                                                                                                                                                                                              | Follower は leader 選出に参加します。これには、クラスタ内の follower の半数以上がアクティブである必要があります。 |
| Observer   | Observer は leader FE からログを同期および再生して、メタデータを更新します。                                                                                                                                                                                                                                                                                                                                           | Observer は主に、クラスタのクエリ並行性を高めるために使用されます。Observer は leader 選出に参加しないため、クラスタに leader 選択のプレッシャーを追加することはありません。|

##### BE

BE は、data storage と SQL 実行を担当します。

- Data storage: BE は同等の data storage 機能を備えています。FE は、事前定義されたルールに基づいてデータを BE に分散します。BE は、取り込まれたデータを変換し、必要な形式でデータを書き込み、データのインデックスを生成します。

- SQL 実行: FE は、クエリのセマンティクスに従って各 SQL クエリを論理実行プランに解析し、次にその論理プランを BE で実行できる物理実行プランに変換します。宛先データを保存する BE がクエリを実行します。これにより、データ伝送とコピーの必要がなくなり、高い query performance が実現します。

### 共有データ

オブジェクトストレージと HDFS は、コスト、信頼性、およびスケーラビリティの利点を提供します。ストレージのスケーラビリティに加えて、ストレージとコンピュートが分離されているため、データをリバランスする必要なく CN ノードを追加および削除できます。

共有データアーキテクチャでは、BE は「コンピュートノード (CN)」に置き換えられます。CN は、データ計算タスクとホットデータのキャッシュのみを担当します。データは、Amazon S3、Google Cloud Storage、Azure Blob Storage、MinIO などの低コストで信頼性の高いリモートストレージシステムに保存されます。キャッシュがヒットすると、query performance は shared-nothing アーキテクチャのパフォーマンスに匹敵します。CN ノードは、必要に応じて数秒以内に追加または削除できます。このアーキテクチャは、ストレージコストを削減し、より優れたリソース分離、高い弾力性とスケーラビリティを保証します。

共有データアーキテクチャは、shared-nothing アーキテクチャと同様にシンプルなアーキテクチャを維持します。FE と CN の 2 種類のノードのみで構成されています。唯一の違いは、ユーザーがバックエンドオブジェクトストレージをプロビジョニングする必要があることです。

![shared-data-arch](../_assets/shared-data.png)

#### ノード

共有データアーキテクチャの Coordinator ノードは、shared-nothing アーキテクチャの FE と同じ機能を提供します。

BE は CN (コンピュートノード) に置き換えられ、ストレージ機能はオブジェクトストレージまたは HDFS にオフロードされます。CN は、データの保存を除く、BE のすべての機能を実行するステートレスコンピュートノードです。

#### ストレージ

StarRocks 共有データクラスタは、オブジェクトストレージ (たとえば、AWS S3、Google GCS、Azure Blob Storage、または MinIO) と HDFS の 2 つのストレージソリューションをサポートしています。

共有データクラスタでは、データファイル形式は、共有なしクラスタ (結合されたストレージとコンピュートを特徴とする) のデータファイル形式と一貫しています。データは Segment ファイルに編成され、さまざまなインデックス作成テクノロジーが Cloud-native table で再利用されます。Cloud-native table は、共有データクラスタで特に使用されるテーブルです。

#### キャッシュ

StarRocks 共有データクラスタは、data storage と計算を分離し、それぞれが独立してスケーリングできるようにすることで、コストを削減し、弾力性を高めます。ただし、このアーキテクチャは query performance に影響を与える可能性があります。

影響を軽減するために、StarRocks は、さまざまなビジネスニーズをより適切に満たすために、メモリ、ローカルディスク、およびリモートストレージを含む多層データアクセスシステムを確立します。

ホットデータに対するクエリは、キャッシュを直接スキャンしてからローカルディスクをスキャンしますが、コールドデータは、後続のクエリを高速化するために、オブジェクトストレージからローカルキャッシュにロードする必要があります。ホットデータをコンピュートユニットの近くに保持することで、StarRocks は真に高性能な計算と費用対効果の高いストレージを実現します。さらに、コールドデータへのアクセスは、データプリフェッチ戦略で最適化されており、クエリのパフォーマンス制限を効果的に排除します。

キャッシュは、テーブルの作成時に有効にできます。キャッシュを有効にすると、データはローカルディスクとバックエンドオブジェクトストレージの両方に書き込まれます。クエリ中、CN ノードは最初にローカルディスクからデータを読み取ります。データが見つからない場合は、バックエンドオブジェクトストレージから取得され、同時にローカルディスクにキャッシュされます。

<QSOverview />